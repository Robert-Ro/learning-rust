## 方法

### 为枚举实现方法

与`struct`一致

## 泛型和特征

### 泛型 Generics

场景：

用同一功能的函数处理不同类型的数据，例如两个数的加法，无论是整数还是浮点数，甚至是自定义类型，都能进行支持。

#### 多态

> 类比 java 中的多态

实际上，泛型就是一种多态。泛型主要目的是为程序员提供编程的便利，减少代码的臃肿，同时可以极大地丰富语言本身的表达能力

#### 泛型详解

表现出一种通用的能力

#### 结构体中使用泛型

- 提前申明
- 字段类型一致

#### 枚举中使用泛型

- `Option<T>`: 值的存在与否
- `Result<T, E>`：值的正确性

#### 方法中使用泛型

为具体的泛型类型实现方法:

```rs
#![allow(unused)]
fn main() {
impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
}
```

#### 泛型的性能

在 Rust 中泛型是零成本的抽象，意味着你在使用泛型时，完全不用担心性能上的问题。

但是任何选择都是权衡得失的，既然我们获得了性能上的巨大优势，那么又失去了什么呢？Rust 是在编译期为泛型对应的多个类型，生成各自的代码，因此损失了**编译速度**和**增大了最终生成文件的大小**。

Rust 通过在编译时进行泛型代码的 **单态化**（`monomorphization`）来保证效率。[单态化](https://course.rs/basic/trait/generic.html)是一个通过填充编译时使用的具体类型，将通用代码转换为特定代码的过程。

编译器所做的工作正好与我们创建泛型函数的步骤相反，编译器寻找所有泛型代码被调用的位置并针对具体类型生成代码。

## 特征

> 类比 java 中`interface`

定义了**一个可以被共享的行为，只要实现了特征，你就能使用该行为**。

### 定义特征

### 默认实现

这样其它类型无需再实现该方法，或者也可以选择重载该方法

### 使用特征作为函数参数
