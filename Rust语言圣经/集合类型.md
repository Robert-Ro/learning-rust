# 集合类型

- Vector
- hashMap
- String

## 动态数组 `Vector`

动态数组允许你存储多个值，**这些值在内存中一个紧挨着另一个排列**，因此访问其中某个元素的成本非常低。动态数组只能存储相同类型的元素，如果你想存储不同类型的元素，可以使用之前讲过的枚举类型或者特征对象。

### 创建

- 关联函数`Vec::new`：如果预先知道要存储的元素个数，可以使用 `Vec::with_capacity(capacity)` 创建动态数组，这样可以避免因为插入大量新数据导致频繁的内存分配和拷贝，提升性能
- 宏`vec![]`: 能在创建同时给予初始化值

### 更新

- `vector.push`

### 销毁

`Vector`与其元素共存亡。当 `Vector` 被删除后，它内部存储的所有内容也会随之被删除。目前来看，这种解决方案简单直白，但是当 `Vector` 中的元素被引用后，事情可能会没那么简单

### 从 `Vector` 中读取元素

- 下标索引 => ele
- get => `Option<T>`(避免数组访问越界的情况)

#### 同时借用多个数组元素

数组的大小是可变的，当旧数组的大小不够用时，`Rust` 会重新分配一块更大的内存空间，然后把旧数组拷贝过来。这种情况下，之前的引用显然会指向一块无效的内存，这非常 `rusty` - 对用户进行严格的教育。

> [从零手撸一个动态数组](https://github.com/rust-lang/nomicon)

### 遍历迭代 Vector 中的元素

```rs
let v = vec![1, 2, 3];
for i in &v {}
for i in &mut v{} // 迭代过程中修改元素
```

### 存储不同类型的元素

通过使用枚举类型和特征对象来实现不同类型元素的存储

## KV 存储 HashMap

`HashMap` 中存储的是一一映射的 `KV` 键值对，并提供了平均复杂度为 `O(1)` 的查询方法，当我们希望通过一个 `Key` 去查询值时，该类型非常有用

### 创建

```rs
use std::collections::HashMap;
HashMap::new()
```

所有的集合类型都是动态的，意味着它们没有固定的内存大小，因此它们底层的数据都存储在内存**堆**上，然后通过一个存储在**栈**中的**引用类型**来访问。同时，跟其它集合类型一致，`HashMap`也是内聚性的，即所有的`K`必须拥有同样的类型，`V`也是如此。

> 跟`Vec`一样，如果预先知道要存储的`KV`对个数，可以使用 `HashMap::with_capacity(capacity)` 创建指定大小的`HashMap`，_避免频繁的内存分配和拷贝，提升性能_

### 使用迭代器和 `collect` 方法创建

> 可能会从另外一个数据结构中，获取到对应的数据，最终生成 `HashMap`

### 所有权转移

`HashMap` 的所有权规则与其它 `Rust` 类型没有区别：

- 若类型实现 `Copy` 特征，该类型会被复制进 `HashMap`，因此*无所谓所有权*
- 若没实现 `Copy` 特征，所有权将被转移给 `HashMap` 中

### 查询 HashMap

- get => Option<T>
- 依次遍历`KV`: `for (key, value) in &scopes`

### 更新 HashMap

- 覆盖已有的值： `insert(k, v)`
- 先查询，不存在则插入新值: `entry(k).or_insert(v)`

注意：

- `or_insert`返回了`&mut v`引用，依次可以通过该可变引用直接修改`map`中对应的值
- 使用`count`引用时，需要先解引用`*count`, 否则会出现类型不匹配

## 哈希函数

若一个复杂点的类型作为 `Key`，那怎么在底层对它进行存储，怎么*使用它进行查询和比较*？ 是不是很棘手？好在我们有**哈希函数**：通过它把 `Key` 计算后映射为哈希值，然后使用*该哈希值来进行存储、查询、比较*等操作。

### 哈希算法

若要追求安全，尽可能减少冲突，同时防止拒绝服务(Denial of Service, DoS)攻击，就要使用密码学安全的哈希函数，HashMap 就是使用了这样的哈希函数。反之若要追求性能，就需要使用没有那么安全的算法。

> 目前，`HashMap` 使用的哈希函数是 `SipHash`，它的性能不是很高，但是安全性很高。`SipHash` 在中等大小的 `Key` 上，性能相当不错，但是对于小型的 `Key` (例如整数)或者大型 `Key` (例如字符串)来说，性能还是不够好。若你需要极致性能，例如实现算法，可以考虑这个库：[ahash](https://github.com/tkaitchuck/ahash)
