# 返回值和错误处理

## Rust 的错误哲学

- 可恢复错误：从系统全局角度来看可接受的错误，如处理用户的访问、操作等错误，只影响某个用户自身的操作进程，不对系统的稳定性造成影响 => `Result<T, E>`
- 不可恢复错误：全局性或系统性的错误，如数组访问越界，影响启动流程的错误等，对系统来说是致命的 => `panic!`

很多编程语言，并不会去取人这些错误，而是直接采用异常的方式去处理。Rust 没有异常，但是 Rust 也有自己的卧龙凤雏：`Result<T, E>`和`panic!`

## panic 深入剖析

### backtrace 栈展开

在真实场景中，错误往往涉及到很长的调用链甚至会深入第三方库，如果没有栈展开技术，错误将难以跟踪处理。

```rs
fn main() {
    let v = vec![1, 2, 3];

    v[99];
}
```

C 语言：**缓冲区溢出**问题

> 当你取到了一个不属于你的值，这在很多时候会导致程序上的逻辑 bug! 有编程经验的人都知道这种逻辑上的 bug 是多么难被发现和修复！因此程序直接崩溃，然后告诉我们问题发生的位置，最后我们对此进行修复，这才是最合理的软件开发流程，而不是把问题藏着掖着：

```rs
RUST_BACKTRACE=1 <code> // 查看调用栈信息
```

### `panic`时的两种终止方式

当出现 `panic!` 时，程序提供了两种方式来处理终止流程: **栈展开** 和 **直接终止**。

- 默认的方式就是 **栈展开**：这意味着 `Rust` 会回溯栈上数据和函数调用，因此也意味着更多的善后工作，好处是可以给出充分的报错信息和栈调用信息，便于事后的问题复盘

- **直接终止**，顾名思义，不清理数据就直接退出程序，善后工作交与操作系统来负责

### 线程`panic`后，程序会否终止？

长话短说，如果是 `main` 线程，则程序会终止，如果是其它子线程，该线程会终止，但是不会影响 `main` 线程。因此，尽量不要在 `main` 线程中做太多任务，将这些任务交由子线程去做，就算子线程 `panic` 也不会导致整个程序的结束。

具体解析见[panic 原理剖析](https://course.rs/basic/result-error/panic.html#panic%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90)

### 何时该使用`panic!`

#### 可能导致全局有害状态时

有害状态大概分为几类：

- 非预期的错误: 用户输入
- 后续代码的运行会受到显著影响： http 请求
- 内存安全的问题： 数组越界

## 可恢复的错误 Result

### 对返回的错误进行处理

- `match` 模式匹配
- `expect`和`unwrap`简化

### 传播错误

- `Err(e)`
- `?`: 使用**宏**简化处理, 可以自动进行类型提升（转换）
