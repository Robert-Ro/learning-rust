# 结构体
用来更好的抽象问题，结构体`struct`。其他语言也具有类似的结构，如`object`，`record`

结构体与元组类似，都是由多种类型组合而成。但是与元组不同的是，结构体可以为内部的每个字段起一个富有含义的名称。因此结构体更加灵活更加强大，无需依赖这些字段的顺序来访问和解析他们。
## 语法
### 定义结构体
- 关键词struct
- 清晰的结构体名称
- 有名字的结构体字段
### 创建结构体
- 初始化实例时，需要为每个字段进行初始化
- 初始化时的字段顺序无需安装定义的顺序来
### 访问结构体
与其他语言访问对象一样访问
### 结构体更新语法
`··`操作符: 根据已有的结构体实例，创建新的结构体实例， 必须在结构体尾部使用。
- 所有权问题：
  - `Copy` trait: 简单类型
  - `Clone` trait：复杂类型
## 结构体的内存排列
![](https://course.rs/img/struct-01.png)
从图中可以清晰的看出`File`结构体两个字段`name`和`data`分别拥有底层两个`[u8]`数组的所有权(`String`类型的底层也是`[u8]`数组)，通过`ptr`指针指向底层数组的内存地址,这里你可以把`ptr`指针理解为`Rust`中的引用类型。

把结构体中具有所有权的字段转移出去后，将无法再访问该字段，但是可以正常访问其它的字段.
## 元组结构体(Tuple Struct)
结构体必须要有名称，但是结构体的字段可以没有名称，这种结构体长得很像元组，因此被称为元组结构体，如：
```rs
struct Color(i32,i32,i32);
struct Point(i32,i32,i32);
let black = Color(0,0,0);
```
元组结构体在你希望有一个整体名称，但是又不关心里面字段的名称时将非常有用。
## 元结构体(Unit-like Struct)
如果你定义一个类型，但是又不关系该类型的内容，只关心它的行为时，就可以使用`元结构体`：
```rs
struct AlwaysEqual;
let subject = AlwaysEqual;
// 我们不关心为AlwaysEqual的字段数据，只关心它的行为，因此将它声明为元结构体，然后再为它实现某个特征
impl SomeTrait for AlwaysEqual {

}
```
## 结构体数据的所有权
之前定义的结构体中都是使用了拥有自身所有权的`String`而不是基于引用类型的`&str`字符串切片类型。

当然也可以让结构体从其他对象借用数据，不过这么做，就需要引入生命周期这个新概念(复杂的概念)，简而言之，生命周期能确保结构体的作用范围要比它所借用的数据的作用范围要小。