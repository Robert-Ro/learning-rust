## 方法

### 为枚举实现方法

与`struct`一致

## 泛型和特征

### 泛型 Generics

场景：

用同一功能的函数处理不同类型的数据，例如两个数的加法，无论是整数还是浮点数，甚至是自定义类型，都能进行支持。

#### 多态

> 类比 java 中的多态

实际上，泛型就是一种多态。泛型主要目的是为程序员提供编程的便利，减少代码的臃肿，同时可以极大地丰富语言本身的表达能力

#### 泛型详解

表现出一种通用的能力

#### 结构体中使用泛型

- 提前申明
- 字段类型一致

#### 枚举中使用泛型

- `Option<T>`: 值的存在与否
- `Result<T, E>`：值的正确性

#### 方法中使用泛型

为具体的泛型类型实现方法:

```rs
#![allow(unused)]
fn main() {
impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
}
```

#### 泛型的性能

在 Rust 中泛型是零成本的抽象，意味着你在使用泛型时，完全不用担心性能上的问题。

但是任何选择都是权衡得失的，既然我们获得了性能上的巨大优势，那么又失去了什么呢？Rust 是在编译期为泛型对应的多个类型，生成各自的代码，因此损失了**编译速度**和**增大了最终生成文件的大小**。

Rust 通过在编译时进行泛型代码的 **单态化**（`monomorphization`）来保证效率。[单态化](https://course.rs/basic/trait/generic.html)是一个通过填充编译时使用的具体类型，将通用代码转换为特定代码的过程。

编译器所做的工作正好与我们创建泛型函数的步骤相反，编译器寻找所有泛型代码被调用的位置并针对具体类型生成代码。

## 特征

> 类比 java 中`interface`

定义了**一个可以被共享的行为，只要实现了特征，你就能使用该行为**。

### 定义特征

### 默认实现

这样其它类型无需再实现该方法，或者也可以选择重载该方法

### 使用特征作为函数参数

### 特征约束

> 类似`ts`中的`T extends xx`

虽然 `impl Trait` 这种语法非常好理解，但是实际上它只是一个语法糖：

```rs
pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}
```

真正的完整书写形式如上所述，形如 `T:Summary` 被称为特征约束。

#### 多重约束

除了单个约束条件，我们还可以指定多个约束条件，例如除了让参数实现 `Summary` 特征外，还可以让参数实现 `Display` 特征以控制它的格式化输出：

```rs
pub fn notify<T: Summary + Display>(item: &T) {}
```

#### Where 约束

当特征约束变得很多时，函数的签名将变得很复杂：

```rs
#![allow(unused)]
fn main() {
    fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {}
}
```

严格来说，上面的例子还是不够复杂，但是我们还是能对其做一些形式上的改进，通过 `where`：

```rs
#![allow(unused)]
fn main() {
    fn some_function<T, U>(t: &T, u: &U) -> i32
        where T: Display + Clone,
          U: Clone + Debug
    {
}
```

#### 使用特征约束有条件的实现方法或特征

### 函数返回中的 `impl Trait`

这种 `impl Trait` 形式的返回值，在一种场景下非常非常有用，那就是返回的真实类型非常复杂，你不知道该怎么声明时(毕竟 Rust 要求你必须标出所有的类型)，此时就可以用 `impl Trait` 的方式简单返回

### 通过`derive`派生特征

在本书中，形如 `#[derive(Debug)]` 的代码已经出现了很多次，这种是一种特征派生语法，被 `derive` 标记的对象会自动实现对应的默认特征代码，继承相应的功能。

例如 `Debug` 特征，它有一套自动实现的默认代码，当你给一个结构体标记后，就可以使用 `println!("{:?}",s)` 的形式打印该结构体的对象。

总之，`derive` 派生出来的是 Rust 默认给我们提供的特征，在开发过程中极大的**简化了自己手动实现相应特征的需求**，当然，如果你有特殊的需求，还可以自己手动重载该实现。

详细的 `derive` 列表参加[附录-派生特征](https://course.rs/appendix/derive.html)。

### 调用方法需要引入特征

在一些场景中，使用 `as` 关键字做类型转换会有比较大的限制，因为你想要在类型转换上拥有完全的控制，例如处理转换错误，那么你将需要 `TryInto`：

## 特征对象

### 特征对象定义

**特征对象**指向实现了`Draw` 特征的类型的实例，也就是指向了 `Button` 或者 `SelectBox` 的实例，这种映射关系是存储在一张表中，可以在运行时通过特征对象找到具体调用的类型方法。

可以通过`&`引用或者`Box<T>`智能指针的方式来创建特征对象:

- `draw1` 函数的参数是 `Box<dyn Draw>` 形式的特征对象，该特征对象是通过 `Box::new(x)` 的方式创建的
- `draw2` 函数的参数是 `&dyn Draw` 形式的特征对象，该特征对象是通过 `&x` 的方式创建的
- `dyn` 关键字只用在特征对象的类型声明上，在创建时无需使用 `dyn`

#### `&dyn`和`Box<dyn>`的区别
// TODO