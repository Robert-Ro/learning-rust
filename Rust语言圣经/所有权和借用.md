### 所有权和借用

内存安全几乎都是通过`GC`的方式实现，但是`GC`会引来性能、内存占用以及 Stop the world 等问题，在高性能场景和系统编程上是不可接受的，因此`Rust`采用了与(错)众(误)不(之)同(源)的方式：**所有权系统**。

#### 所有权

申请、释放资源三种流派：

- 垃圾回收机制：在程序运行时不断寻找不再使用的内存，典型代表：`Java`, `Go`
- 手动管理内存的分配和释放：通过函数调用的方式来申请和释放内存，典型代表：C++
- 通过所有权来管理内存：在编译时根据一系列规则进行检查(只在编译时进行检查，因此不对运行时有任何性能影响)

#### 堆和栈

- 写入方面：入栈比在堆上分配内存要快，因为入栈时操作系统无需分配新的空间，只需要将新数据放入栈顶即可。相比之下，**在堆上分配内存则需要更多的工作**，这是因为操作系统必须首先找到一块足够存放数据的内存空间，接着做一些记录为下一次分配做准备。

- 读取方面：得益于 CPU 高速缓存，使得处理器可以减少对内存的访问，高速缓存和内存的访问速度差异在 10 倍以上！**栈数据往往可以直接存储在 CPU 高速缓存中**，而**堆数据只能存储在内存中**。_访问堆上的数据比访问栈上的数据慢，因为必须先访问堆再通过堆上的指针来访问内存_。

#### 所有权原则

- Rust 中每一个值都**有且只有**一个所有者(变量)
- 当所有者(变量)**离开作用域范围时**，这个值将被丢弃(free)

##### String 类型

字符串字面值是很方便的，但是它并不适用于所有场景。原因有二：

- **字符串字面值是不可变的**，因为被硬编码到程序代码中
- 并非所有字符串的值都能在编写代码时得知

字符串字面值就完全无用武之地。 为此，`Rust`为我们提供动态字符串类型:`String`, 该类型**被分配到堆上**，因此**可以动态伸缩**，也就能**存储在编译时大小未知的文本**。
`String`类型是一个复杂类型，由存储在栈中的**堆指针**、**字符串长度**、**字符串容量**共同组成，其中堆指针是最重要的，它**指向了真实存储字符串内容的堆内存**，至于长度和容量，如果你有 Go 语言的经验，这里就很好理解：**容量是堆内存分配空间的大小**，**长度是目前已经使用的大小**.

- 拷贝`String`和存储在堆上的字节数组 如果该语句是拷贝所有数据(深拷贝)，那么无论是`String`本身还是底层的堆上数据，都会被全部拷贝，这对于性能而言会造成非常大的影响
- 只拷贝`String`本身 这样的拷贝非常快，因为在 64 位机器上就拷贝了 8 字节的指针、8 字节的长度、8 字节的容量，总计 24 字节，但是带来了新的问题，还记得我们之前提到的所有权规则吧？其中有一条就是，一个值只允许有一个所有者，而现在这个值(堆上的真实字符串数据)有了两个所有者：`s1`和`s2`。

##### 克隆(深拷贝)

确实需要深度复制`String`中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做`clone`的方法。

> 对于执行较为频繁的代码(热点路径)，使用 clone 会极大的降低程序性能，需要小心使用！

##### 拷贝(浅拷贝)

浅拷贝只发生在栈上，因此性能很高，在日常编程中，浅拷贝无处不在。

通用规则：任何基本类型的组合可以是 `Copy` 的，不需要分配内存或某种形式资源的类型是 `Copy` 的。如下是一些 `Copy` 的类型：

- 所有整数类型，比如 `u32`。
- 布尔类型，`bool`，它的值是 `true` 和 `false`。
- 所有浮点数类型，比如 `f64`。
- 字符类型，`char`。
- 元组，当且仅当其包含的类型也都是 `Copy` 的时候。比如，`(i32, i32)` 是 `Copy` 的，但 `(i32, String)` 就不是。

##### 函数传值与返回

所有权很强大，避免了内存的不安全性，但是也带来了一个新麻烦: **总是把一个值传来传去来使用它**。 **传入一个函数，很可能还要从该函数传出去，结果就是语言表达变得非常啰嗦**，幸运的是，Rust 提供了**新功能**解决这个问题。

#### 引用与借用

> 如果仅仅支持通过转移所有权的方式获取一个值，那会让程序变得复杂

Rust 通过借用(**Borrowing**)这个概念来达成上述的目的: **获取变量的引用，称之为借用(borrowing)**。正如现实生活中，如果一个人拥有某样东西，你可以从他那里借来，当使用完毕后，也必须要物归原主.

##### 引用与解引用

**常规引用**是一个指针类型，指向了对象存储的内存地址。使用解引用符`*`来解出应用所指向的值(也就是**解引用**)

##### 不可变引用

> `&variable`

##### 可变引用

> `&mut variable`

可变引用同时只能存在一个: 同一作用域，特定数据只能有一个可变引用

这种限制的好处就是使`Rust`在编译期就避免数据竞争，数据竞争可由以下行为造成：
- 两个或更多的指针同时访问同一数据
- 至少有一个指针被用来写入数据
- 没有同步数据访问的机制

可变引用与不可变引用不能同时存在: 正在借用不可变引用的用户，肯定不希望他借用的东西，被另外一个人莫名其妙改变了。多个不可变借用被允许是因为没有人会去试图修改数据，每个人都只读这一份数据而不做修改，因此不用担心数据被污染。
##### 悬垂引用（Dangling References）
悬垂引用也叫做悬垂指针，**指的是指针指向某个值后，这个值被释放掉了，而指针仍然存在，其指向的内存可能不存在任何值或已被其它变量重新使用**。在 Rust 中编译器可以确保引用永远也不会变成悬垂状态：当你拥有一些数据的引用，编译器可以确保数据不会在其引用之前被释放，**要想释放数据，必须先停止其引用的使用**。
##### 借用规则总结
总的来说，借用规则如下：

- 同一时刻，你只能拥有要么**一个可变引用**, 要么**任意多个不可变引用**
- 引用必须总是有效的