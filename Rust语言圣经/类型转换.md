# 类型转换

## as 转换

> 使用类型转换需要小心, 注意整型的表示范围

`Rust` 是类型安全的语言，因此在 `Rust` 中做类型转换不是一件简单的事，这一章节我们将对 `Rust` 中的类型转换进行详尽讲解。

### 内存地址转换为指针

### 强制类型转换的边角知识

1. 数组切片原生指针之间的转换，不会改变数组占用的内存字节数，尽管数组元素的类型发生了改变：

2. 转换不具有传递性 就算 `e as U1 as U2` 是合法的，也不能说明 `e as U2` 是合法的（`e` 不能直接转换成 U2）

## TryInto 转换

在一些场景中，使用 `as` 关键字会有比较大的限制。如果你想要在类型转换上拥有完全的控制而不依赖内置的转换，例如处理转换错误:

try_into 转换会捕获大类型向小类型转换时导致的溢出错误

## 通用类型转换

> 虽然 `as` 和 `TryInto` 很强大，但是只能应用在数值类型上

### 强制类型转换

在某些情况下，类型是可以进行隐式强制转换的，虽然这些转换弱化了 `Rust` 的类型系统，但是它们的存在是为了让 `Rust` 在大多数场景可以工作(说白了，帮助用户省事)，而不是报各种类型上的编译错误。

### 点操作符

方法调用的点操作符看起来简单，实际上非常不简单，它在调用时，会发生很多魔法般的类型转换，例如：**自动引用**、**自动解引用**，**强制类型转换直到类型能匹配**等。

完全限定语法:
- 值方法调用
- 引用方法调用
- 解引用方法调用
