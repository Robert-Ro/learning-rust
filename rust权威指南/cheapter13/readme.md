# 函数式语言特性：迭代器与闭包

## 闭包(closures)

> 能够捕获环境的匿名函数
> Rust 中的闭包是一种可以存入变量或作为参数传递给其他函数的匿名函数。

```rs
fn  add_one_v1   (x: u32) -> u32        { x + 1 }
let add_one_v2 = |x: u32| -> u32     { x + 1 };
let add_one_v3 = |x|                            { x + 1 };
let add_one_v4 = |x|                       x + 1  ;
```

### 使用闭包捕获上下文环境

```rs
    let x = 4;
    let equal_to_x = |z: i32| -> bool { z == x };
    let y = 4;
    assert!(equal_to_x(y)); // true
```

当闭包从环境中捕获值时，它会使用**额外的空间来存储这些值**以便在闭包体内使用。在大多数情况下，我们都不需要在执行代码时捕获环境，也不想要为这种场景产生额外的内存开销。因为函数不被允许从环境中捕获变量，所以定义和使用函数永远不会产生这类开销。

闭包可以通过 3 种方式从它们的环境中捕获值，这和函数接收参数的 3 种方式是完全一致的：获取所有权、可变借用及不可变借用。这 3 种方式被分别编码在如下所示的 3 种 Fn 系列的 trait 中：

- `FnOnce`意味着闭包可以从它的封闭作用域中，也就是闭包所处的环境中，消耗捕获的变量。为了实现这一功能，闭包必须在定义时取得这些变量的所有权并将它们移动至闭包中。这也是名称`FnOnce`中 Once 一词的含义：**因为闭包不能多次获取并消耗掉同一变量的所有权，所以它只能被调用一次**
- FnMut 可以从环境中可变地借用值并对它们进行修改
- Fn 可以从环境中不可变地借用值

## 迭代器(iterator)

迭代器模式允许你依次为序列中的每一个元素执行某些任务。迭代器会在这个过程中负责遍历每一个元素并决定序列何时结束。

在 Rust 中，迭代器是惰性的(layzy)。这也就意味着创建迭代器后，除非你主动调用方法来消耗并使用迭代器，否则它们不会产生任何的实际效果。

### Iterator trait 和 next 方法

```rs
let v1 = vec![1, 2, 3];
let v1_iter = v1.iter();
```

```rs
    vec![1, 2, 3].iter(); //一个不可变引用的迭代器
    vec![1, 2, 3].into_iter(); // 取得动态数组所有权并返回元素本身的迭代器
    vec![1,2,3].iter_mut(); // 可变引用的迭代器
```

### 消耗迭代器的方法

这些调用 next 的方法也被称为**消耗适配器**(consuming adaptor)，因为它们同样消耗了迭代器本身。

### 生成其他迭代器的方法

Iterator trait 还定义了另外一些被称为迭代器适配器(iterator adaptor)的方法，

#### map

```rs
   let v1: Vec<i32> = vec![1, 2, 3];
        // v1.iter().map(|x| x + 1); // iterators are lazy and do nothing unless consumed
    let v2: Vec<i32> = v1.iter().map(|x| x + 1).collect();
        assert_eq!(v2, vec![2, 3, 4]);
        println!("{:?}", v2);
```
### 使用闭包捕获环境

### 使用Iterator trait来创建自定义迭代器
实现Iterator trait
#### 使用其他的Iterator trait方法

## 应用

## 闭包和迭代器的运行性能
