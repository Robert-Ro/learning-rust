# 智能指针

指针是一个通用概念，它指代那些包含**内存地址**的变量。这个地址被用于索引，或者说用于"指向内存中的其他数据"。

引用是最常见的指针，用符合&表示，会借用它所指向的值。它除了指向数据外没有任何其他功能，也没有额外的开销。

而智能指针则是一些数据结构，他们的行为**类似于指针**但**拥有额外的元数据和附加功能**。

引用计数智能指针，通过记录所有者的数量来使一份数据被多个所有者同时持有，并在没有任何所有者时自动清理数据。

- 引用：借用数据的指针
- 智能指针：本身就拥有它们指向的数据

> 智能指针类似 {}？

通常使用结构体来实现智能指针，但区别于一般结构体的地方，它们通常会实现`Deref`和`Drop`这两个 trait。

- `Deref trait`使得智能指针结构体的实例拥有与引用一致的行为，它使你可以编写出能够同时用于引用和智能指针的代码
- `Drop trait`使你可以自定义智能指针离开作用域时运行的代码

标准库中常用的智能指针：

- Box<T>, alloc value on the heap memory
- Rc<T>, 多重所有权的引用计数类型
- Ref<T>和 RefMut<T>, 可以通过 RefCell<T>访问，是一种可以**在运行时而不是编译时执行借用规则**的类型

## Box<T>

分配数据在堆上，并在栈中保留一个指向堆数据的指针

### 使用场景

- 当你拥有一个无法在编译时确定大小的类型，但又想要在一个要求固定尺寸的上下文环境中使用这个类型的值时
- 当你需要传递大量数据的所有权，但又不希望产生大量数据的复制行为时
- 当你希望拥有一个实现了指定 trait 的类型时，但又不关心具体的类型时

### 在堆上分配存储数据

```rs
let x = Box::new(value: T)
```

### 定义递归类型

Rust 必须在编译时知道每一种类型占据的空间大小，但有一种被称作递归(`recursive`)的类型却无法在编译时被确定具体大小。递归类型的值可以在自身中存储另一个相同类型的值，因为*这种嵌套在理论上可以无穷无尽地进行下去*，所以 Rust 根本无法计算出一个递归类型需要的具体空间大小。但是，**装箱有一个固定的大小**，我们只需要在递归类型的定义中使用装箱便可以创建递归类型了。

## Deref trait

\*x: 跟踪引用并跳转到它指向的值

### 把 Box<T>当成引用来操作

### 定义我们自己的智能指针

实现 Deref Trait

```rs
impl<T> Deref for MyBox<T> {
   type Target = T;
   fn deref(&self) -> &T {
   }
}
```

### 函数和方法的隐式解引用转换
### 借助Drop trait在清理时运行代码
### 使用std::mem::drop提前丢弃值
```rs
std::mem::drop()
```
## 基于引用计数的智能指针Rc<T>
所有权在大多数情况下都是清晰的：对于一个给定的值，你可以准确地判断出哪个变量拥有它。

但在**某些场景**中，单个值也可能同时被多个所有者持有。
例如，在图数据结构中，多个边可能会指向相同的节点，而**这个节点从概念上来讲就同时属于所有指向它的边**。
一个节点只要在任意指向它的边还存在时就不应该被清理掉。

Rust提供了一个名为`Rc<T>`的类型来支持多重所有权，它名称中的
Rc是`Reference counting`（引用计数）的缩写。`Rc<T>`类型的实例会在
内部维护一个用于记录值引用次数的计数器，从而确认这个值是否仍在使用。
如果对一个值的引用次数为零，那么就意味着这个值可以被安全地清理掉，而不会触发引用失效的问题。

**`Rc<T>`只能被用于单线程场景中**
### 使用Rc<T>共享数据
### RefCell<T>和内部可变性模式
内部可变性(interior mutability)是Rust的设计模式之一，它允许你在只持有不可变引用的前提下对数据进行修改；
为了能够改变数据，内部可变性模式在它的数据结构中使用了unsafe代码来绕过Rust正常的可变性和借用规则
#### 使用RefCell<T>在运行时检查借用规则
> 只适用于单线程场景
- `Rc<T>`允许一份数据有多个所有者，而`Box<T>`和`RefCell<T>`都只有一个所有者
- `Box<T>`允许在编译时检查的可变或不可变借用，`Rc<T>`仅允许编译时检查的不可变借用，`RefCell<T>`允许运行时检查的可变或不可变借用
- 由于`RefCell<T>`允许我们在运行时检查可变借用，所以即便`RefCell<T>`本身是不可变的，我们仍然能够更改其中存储的值。
#### 内部可变性：可变地借用一个不可变的值
`RefCell<T>`并没有完全绕开借用规则：我们虽然使用内部可变性通过了编译阶段的借用检查，但**借用检查的工作仅仅是被延后到了运行阶段**。
如果你违反了借用规则，那么就会得到一个panic! 而不再只是编译时的错误。