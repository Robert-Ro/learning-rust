## 进程与线程
### 多线程问题
- 竞争状态
- 死锁
- bug难以复制和修复

### 实现线程的方式
- 通过调用OS的API来创建线程：1:1模型
  - 需要较小的运行时
- 语言自己实现的线程(绿色线程)：M:N模型
  - 需要更大的运行时
#### Rust：需要权衡运行时的支持
- 仅提供1:1模型
- 社区提供M:N模型
#### 通过Spawn创建新线程
- thread::spawn函数可以创建新线程：
  - 参数：一个闭包(在新线程里运行的代码)
#### 通过join Handle来等待所有线程的完成
- thread::spawn函数的返回值类型是JoinHandle
- JoinHandle持有值的所有权
- join方法：调用handle的join方法会阻止当前运行线程的执行，直到handle所表示的这些线程终结
#### 使用move闭包
move强制获取所有权
- move闭包通常和thread::spawn函数一起使用，它允许使用其他线程的数据
## 消息传递
- 一种很流行且能保证安全并发的技术就是：**消息传递**
- 线程(或Actor)通过彼此发送消息(数据)来进行通信
- Go语言的名言：**不要用共享内存来通信，要用通信来共享内存**
- Rust: Channel(标准库提供)
### Channel
- Channel包含: 发送端、接收端
- 接收端会检查和接收到达的数据
- 如果发送端、接收端中任意一端被丢弃了，那么channel就"关闭"了

#### 创建Channel
- 使用mpsc::channel函数来创建Channel
  - mpsc表示multiple producer, single consumer(多个生产者、一个消费者)
  - 返回一个tuple(元组): 里面元素分别为发送端、接收端

#### Channel和所有权转移
- 所有权在消息传递中非常重要：能帮你编写安全、并发的代码
#### 通过克隆获取多个发送者
- 接受消息的顺序不一定，无法保证

## 使用共享来实现并发
- Rust支持通过共享状态来实现并发
- Channel类似单所有权：一旦将值的所有权转移值Channel，就无法使用它了，
- 共享内存并发类似多所有权，多个线程可以同时访问同一块内存
### 使用Mutex来每次只允许一个线程来访问数据
#### Mutex
- mutual exclusion(互斥锁)的简写
#### Mutex的两条规则
- 在使用数据之前，必须尝试索取锁(lock)
- 使用完mutex所保护的数据，必须对数据进行解锁，以便其他线程可以获取锁
#### 多线程共享
#### 多线程的多重所有权