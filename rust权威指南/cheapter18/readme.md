# 模式匹配

用于匹配类型结构的特殊语法，时而复杂，时而简单。将模式与 match 表达式或其他工具配合使用可以更好地控制时序流程。一个模式通常由以下组件组合而成：

- 字面量
- 解构的数组、枚举、结构体或元组
- 变量
- 通配符
- 占位符

## 所有可以使用模式的场合

### match 分支

> 必需穷尽匹配值的所有可能性

```rs
match value{
  模式1 => 表达式1,
  模式2 => 表达式2,
  模式3 => 表达式3,
  _模式 => 匹配所有可能的值，且不能被绑定到任何一个变量上
}
```

### if let 条件表达式

- 可充当匹配单个分支的 match 表达式，还有一个可选的 else 分支
- 以混合使用`if let`、`else if`及`else if let`表达式来进行匹配
  > 1)不强制穷尽值的所有可能性，2)可能会遗漏某些需要处理的情形

### while let 条件循环

与`if let`类似，但会反复执行同一个模式匹配直到出现失败的情形

### for 循环

`for`循环是`Rust`代码中最为常用的循环结构，而你同样可以在`for`循环内使用模式。`for`语句中紧随关键字`for`的值就是一个模式，比如`for x in y`中的`x`

enumerate 方法来作为迭代器的适配器, 它会在每次迭代过程中生成一个包含值本身及值索引的**元组**

### let 语句

最基本的 let 语句也用到了模式。

```rs
let PATTERN = EXPRESSION;
```

在类似于`let x = 5;`的语句中，单独的变量名作为最朴素的模式被放于 PATTERN 对应的位置。Rust 会将表达式与模式进行比较，并为所有找到的名称赋值。因此，在`let x = 5; `这个示例中，**x 作为模式表达的含义是“将此处匹配到的所有内容绑定至变量 x”**。因为 x 就是整个模式本身，所以它实际上意味着“无论表达式会返回什么样的值，我们都可以将它绑定至变量 x 中”。

#### 解构元组

```rs
let (x, y, z) = (1, 2, 3);
let (x, y) = (1, 2, 3); // compile error: expected a tuple with 3 elements, found one with 2 elements
// 忽略元组中的一个或多个值
let (x, y, _) = (1, 2, 3);
let (x, y, ..) = (1, 2, 3);
let (x, _, ..) = (1, 2, 3);
```

### 函数的参数

函数的参数同样也是模式。

```rs
// 签名中的x部分就是一个模式
fn foo(x: i32) {
    // 在此编写函数代码
}
// 使用模式去匹配元组
fn print_coordinates(&(x, y): &(i32, i32)) {
    println!("Current location: ({}, {})", x, y);
}
// 类似于函数的参数列表，我们同样可以在闭包的参数列表中使用模式
let x = |x: i32| x
```

## 可失败性：模式是否会匹配失败

模式可以被分为不可失败(`irrefutable`)和可失败(`refutable`)两种类型

### 不可失败的模式

不可失败的模式能够匹配任何传入的值。例如，语句`let x = 5;`中的`x`便是不可失败模式，因为它能够匹配表达式
右侧所有可能的返回值

### 可失败的模式

可失败模式则可能因为某些特定的值而匹配失败。例如，表达式`if let Some(x) = a_value`中的`Some(x)`便是可失
败模式。如果`a_value`变量的值是`None`而不是`Some`，那么表达式左侧的`Some(x)`模式就会发生不匹配的情况。

- **函数参数**、**let 语句**及**for 循环**只接收不可失败模式
- `if let`和`while let`表达式则只接收可失败模式

### 小结

在`match`表达式的匹配分支中，**除了最后一个，其他必须全部使用可失败模式**，而**最后的分支则应该使用不可失败模式，因为它需要匹配值的所有剩余的情形**。`Rust`允许你在仅有一个分支的`match`表达式中使用不可失败模式，但这种语法几乎没有任何用处，它可以被简单的`let`语句所代替。

## 模式语法

### 匹配字面量

### 匹配命名变量

命名变量（named variable）是一种可以匹配任何值的不可失败模式，我们在本书中相当频繁地使用了这一模式。值得一提的是，当你在 match 表达式中使用命名变量时，情况可能会变得稍微有些复杂。由于 match 开启了一个新的作用域，所以被定义在 match 表达式内作为模式一部分的变量会覆盖掉 match 结构外的同名变量，正如覆盖其他普通变量一样。

### 多重模式

你可以在`match`表达式的分支匹配中使用`|`来表示或(`or`)的意思，它可以被用来一次性地匹配多个模式

### 使用..来匹配值区间

范围模式只被允许使用数值或 char 值来进行定义，因为编译器需要在编译时确保范围的区间不为空，而 char 和数值正是 Rust 仅有的可以判断区间是否为空的类型

### 使用解构来分解值

我们可以使用模式来分解结构体、枚举、元组或引用，从而使用这些值中的不同部分。让我们分别来看一看这些用法。

### 忽略模式中的值

- 使用\_忽略整个值
  - 在函数签名中使用`_`， 忽略该参数
  - 使用嵌套的*忽略值的某些部分， `(Some(*), Some(\_))`
  - 忽略一个元组中的多个部分: `(first, _, third, _, fifth)`
  - 通过以*开头的名称来忽略未使用的变量, // **\_x 语法仍然将值绑定到了变量上**, 而*完全不会进行绑定
- 使用..忽略值的剩余部分
  - `{ x, .. }`使用..忽略 Point 中除 x 之外的所有字段
  - `(first, .., last)`只匹配元组中的第一个值和最后一个值，而忽略其他值
  - `(.., second, ..)` 试图以存在歧义的方式使用.. // Error

### 使用匹配守卫添加额外条件

匹配守卫(`match guard`)是附加在`match`分支模式后的`if`条件语句

```rs
let num = Some(4);

match num {
    Some(x) if x < 5 => println!("less than five: {}", x),
    Some(x) => println!("{}", x),
    None => (),
}
```

使用外部变量：

```rs
  let x = Some(5);
    let y = 10;
    match x {
        Some(50) => println!("Got 50"),
        Some(n) if n == y => println!("Matched, n = {:?}, ", n),
        _ => println!("Default case, x = {:?}", x),
    }

    println!("x: {:?}, y: {}", x, y);
```

### @绑定
`@`运算符允许我们在测试一个值是否匹配模式的同时创建存储该值的变量