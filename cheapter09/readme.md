# 错误处理

在 Rust 中，我们将错误分为两大类：可恢复错误与不可恢复错误，相比其他的语言则提供统一的异常处理机制。

## 可恢复错误 Result<T, E>

> 如文件未找到等，一般需要将它们报告给用户并再次尝试进行操作

## 不可恢复错误 panic!

> 往往就是 bug 的另一种说法，比如尝试访问超出数组结尾的位置等
> 代码里总是会出现一些令你束手无策的糟糕情形。为了应对这样的场景，`Rust`提供了一个特殊的`panic!`宏。程序会在`panic!`宏执行时打印出一段错误提示信息，展开并清理当前的调用栈，然后退出程序。这种情况大部分都发生在某个错误被检测到，但程序员却不知该如何处理的时候。

当 panic 发生时，程序会默认开始栈展开。这意味着 Rust 会沿
着调用栈的反向顺序遍历所有调用函数，并依次清理这些函数中的数据。

但是为了支持这种遍历和清理操作，我们需要在二进制中存储许多额外信息。除了展开，我们还可以选择立即终止程序，它会直接结束程序且不进行任何清理工作，程序所使用过的内存只能由操作系统来进行回收。

假如项目需要使最终二进制包尽可能小，那
么你可以通过在 Cargo.toml 文件中的[profile]区域添加 panic ='abort'来将 panic 的默认行为从展开切换为终止。

```
[profile.release]
panic = 'abort'
```

### 匹配不同的错误

```rs
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open("hello.txt");

    let f = match f {
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("Tried to create file but there was a problem:
{:?}", e),
            },
            other_error => panic!("There was a problem opening the file: {:?}",
other_error),
        },
    };
}
```

### 失败时触发 panic 的快捷方式：unwrap 和 expect

一个被称为`unwrap`的方法实现了我们在示例 9-4 中编写的`match`表达式的效果。当`Result`的返回值是`Ok`变体时，`unwrap`就会返回 Ok 内部的值。而当`Result`的返回值是`Err`变体时，`unwrap`则会替我们调用`panic!`宏。

还有另外一个被称作`expect`的方法，它允许我们在`unwrap`的基础上指定`panic!` 所附带的错误提示信息。使用`expect`并附带上一段清晰的错误提示信息可以阐明你的意图，并使你更容易追踪到`panic`的起源。

### 传播错误

当你编写的函数中包含了一些可能会执行失败的调用时，除了可以在函数中处理这个错误，还可以将这个错误返回给调用者，让他们决定应该如何做进一步处理。

这个过程也被称作**传播错误**，在调用代码时它给了用户更多的控制能力。与编写代码时的上下文环境相比，调用者可能会拥有更多的信息和逻辑来决定应该如何处理错误。

传播错误的模式在 Rust 编程中非常常见，所以 Rust 专门提供了一个问号运算符(?)来简化它的语法。

//TODO ?运算符背后的原理

**?运算符只能被用于返回 Result 的函数**

> 使用了?运算符的函数必须返回`Result`, `Option`或任何实现了`std::ops::Try`的类型。在那些没有返回上述类型的函数里，一旦调用的其他函数返回了`Result<T, E>`，就需要使用`match`或`Result<T, E>`自身的方法来对`Result<T, E>`进行恰当的处理

`Box<dyn Error>`被称作`trait`对象，我们将在第 17 章讨论它。现在，你可以简单地将`Box<dyn Error>`理解为“任何可能的错误类型”

## 要不要使用 panic!

> 同其他语言的 throw error

什么时候应该使用`panic!`，而什么时候又应该返回`Result`呢？代码一旦发生`panic`，就再也没有恢复的可能了。只要你认为自己可以代替调用者决定某种情形是不可恢复的，那么就可以使用`panic!`，而不用考虑错误是否存在可以恢复的机会。当你选择返回一个`Result`值时，你就将这种选择权交给了调用者。调用者可以根据自己的实际情况来决定是否要尝试进行恢复，或者干脆认为`Err`是不可恢复的，并使用`panic!`来将可恢复错误转变为不可恢复错误。因此，我们会在定义一个可能失败的函数时优先考虑使用`Result`方案。

但对于某些不太常见的场景，直接触发`panic`要比返回`Result`更为合适一些。下面，我们会首先讨论为什么`panic`适用于示例、原型和测试等情形。接着，我们会讨论某些编程者确信错误不会发生但编译器却无法做出合理推断的场景。最后，我们会总结一些在库代码中是否应当使用`panic`的通用指导原则。

### 示例、原型和测试

### 当你比编译器拥有更多信息时

### 错误处理的指导原则

### 创建自定义类型来进行有效性验证

```rs
pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Guess value must be between 1 and 100, got {}.", value);
        }

        Guess { value }
    }

    pub fn value(&self) -> i32 {
        self.value
    }
}
```
## 总结
`Rust`中的错误处理功能被设计出来帮助我们编写更加健壮的代码。
- `panic!`宏表示程序正处于一个无法处理的状态下，你需要终止进程运行，而不是基于无效或非法的值继续执行命令
- `Result`枚举可以借助`Rust`的类型系统表明某个操作有失败的可能，并且代码能够从这种失败中恢复过来。

你也可以使用`Result`来强制代码的调用者对可能的成功或失败情形都做出处理。合理地搭配使用`panic!`和`Result`可以让我们的代码在面对无法避免的错误时显得更加可靠。