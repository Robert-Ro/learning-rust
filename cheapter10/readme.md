# 泛型、trait 与生命周期

## 泛型

> 泛型是具体类型或其他属性的抽象替代

### 泛型数据类型

#### 在函数定义中

#### 在结构体定义中

> 要注意，过多的泛型会使代码难以阅读。通常来讲，当你需要在代码中使用很多泛型时，可能就意味着你的代码需要重构为更小的片段。

#### 在枚举定义中

#### 在方法定义中

#### 泛型性能问题

Rust 实现泛型的方式决定了使用泛型的代码与使用具体类型的代码相比不会有任何速度上的差异。
为了实现这一点，Rust 会在编译时执行泛型代码的单态化
（`monomorphization`）。**单态化**是一个在编译期将泛型代码转换为特定代码的过程，它会将所有使用过的具体类型填入泛型参数从而得到有具体类型的代码。

## trait：定义共享行为

`trait`（特征）被用来向`Rust`编译器描述某些特定类型拥有的且能够被其他类型共享的功能，它使我们可以以一种抽象的方式来定义共享行为。我们还可以使用`trait`约束来将泛型参数指定为实现了某些特定行为的类型。

> `trait`与其他语言中常被称为接口（`interface`）的功能类似，但也不尽相同。
> trait vs interface vs mixins

### 定义 trait

类型的行为由该类型本身可供调用的方法组成。当我们可以在不同的类型上调用相同的方法时，我们就称这些类型共享了相同的行为。

```rs
pub trait Summary{
  fn summarize(&self) -> String;
  // 一个trait可以包含多个方法：每个方法签名占据单独一行并以分号结尾。
}
```

### 为类型实现 trait

### 默认实现

```rs
pub trait Summary {
    fn summarize(&self) -> String {
        String::from("(Read more...)")
    }
}
impl Summary for NewsArticle {}
```

### 使用 trait 作为参数

```rs
pub fn notify(item: impl Summary) {
    println!("Breaking news! {}", item.summarize());
}
```

#### 通过+语法来指定多个 trait 约束

```rs
pub fn notify(item: impl Summary + Display) {}
pub fn notify<T: Summary + Display>(item: T) {}
```

#### 使用 where 从句来简化 trait 约束

```rs
fn some_function<T: Display + Clone, U: Clone + Debug>(t: T, u: U) -> i32 {}

fn some_function<T, U>(t: T, u: U) -> i32
    where T: Display + Clone,
          U: Clone + Debug
{}
```

#### 返回实现了 trait 的类型

```rs
fn returns_summarizable() -> impl Summary {
    Tweet {
        username: String::from("horse_ebooks"),
        content: String::from("of course, as you probably already know, people"),
        reply: false,
        retweet: false,
    }
}
```

#### 使用 trait 约束来修复 largest 函数

#### 使用 trait 约束来有条件地实现方法

##### 覆盖实现

对满足 trait 约束的所有类型实现 trait 也被称作覆盖实现（blanket implementation）

## 生命周期

### 使用生命周期保证引用的有效性

Rust 的每个引用都有自己的生命周期（**lifetime**），它对应着引用保持有效性的作用域。在大多数时候，生命周期都是隐式且可以被推导出来的，就如同大部分时候类型也是可以被推导的一样。

当出现了多个可能的类型时，我们就必须手动声明类型。类似地，当引用的生命周期可能以不同的方式相互关联时，我们就必须手动标注生命周期。Rust 需要我们注明泛型生命周期参数之间的关系，来确保运行时实际使用的引用一定是有效的。

### 使用生命周期来避免悬垂引用

```rs
// 尝试在值离开作用域时使用指向它的引用
{
 ❶ let r;

    {
     ❷ let x = 5;
     ❸ r = &x;
 ❹ }

 ❺ println!("r: {}", r);
}
```

### 借用检查器

Rust 编译器拥有一个**借用检查器**（borrow checker），它被用于比较不同的作用域并确定所有借用的合法性。

#### r 与 x 的生命周期的标注

### 函数中的泛型生命周期

```rs
fn longest(a: &str, b: &str) -> &str {
    //expected named lifetime parameter
    if a.len() > b.len() {
        a
    } else {
        b
    }
}
```

在我们定义这个函数的时候，我们并不知道会被传入函数的具体值，所以也不能确定到底是 if 分支还是 else 分支会得到执行。我们同样也无法知晓传入的引用的具体生命周期，所以就无法像示例 10-18 和 10-19 那样通过分析作用域来确定返回的引用是否有效。借用检查器自然也无法确定这一点，因为它不知道 x 与 y 的生命周期是如何与返回值的生命周期相关联的。为了解决这个问题，我们会添加一个泛型生命周期参数，并用它来定义引用之间的关系，进而使借用检查器可以正
常地进行分析。

### 生命周期标注语法

生命周期的标注并不会改变任何引用的生命周期长度。如同使用了泛型参数的函数可以接收任何类型一样，使用了泛型生命周期的函数也可以接收带有任何生命周期的引用。在不影响生命周期的前提下，标注本身会被用于描述多个引用生命周期之间的关系。

生命周期的标注使用了一种明显不同的语法：它们的参数名称必须以撇号（'）开头，且通常使用全小写字符。与泛型一样，它们的名称通常也会非常简短。'a 被大部分开发者选择作为默认使用的名称。

我们会将生命周期参数的标注填写在&引用运算符之后，并通过一个空格符来将标注与引用类型区分开来。

```rs
&i32 //引用
&'a i32 //拥有显示生命周期的引用
&'a mut i32 //拥有显示生命周期的可变引用
```

单个生命周期的标注本身并没有太多意义，标注之所以存在是为了向 Rust 描述多个泛型生命周期参数之间的关系。

例如，假设我们编写了一个函数，这个函数的参数 first 是一个指向 i32 的引用，并且拥有生命周期'a。它的另一个参数 second 同样也是指向 i32 且拥有生命周期'a 的引用。_这样的标注就意味着：first 和 second 的引用必须与这里的泛型生命周期存活一样长的时间_。

### 函数签名中的生命周期标注

现在，让我们回过头来看一看`longest`函数上下文中的生命周期标注。如同泛型参数一样，我们同样需要在函数名与参数列表之间的尖括号内声明泛型生命周期参数。_在这个签名中我们所表达的意思是：参数与返回值中的所有引用都必须拥有相同的生命周期_。

```rs
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

这段代码的函数签名向`Rust`表明，**函数所获取的两个字符串切片参数的存活时间，必须不短于给定的生命周期'a**。这个函数签名同时也意味着，**从这个函数返回的字符串切片也可以获得不短于'a 的生命周期**。

而这些正是我们需要 Rust 所保障的约束。**记住，当我们在函数签名中指定生命周期参数时，我们并没有改变任何传入值或返回值的生命周期。我们只是向借用检查器指出了一些可以用于检查非法调用的约束**。

注意，`longest`函数本身并不需要知道 x 与 y 的具体存活时长，只要某些作用域可以被用来替换`'a`并满足约束就可以了。

当我们在函数中标注生命周期时，这些标注会出现在函数签名而不是函数体中。Rust 可以独立地完成对函数内代码的分析。但是，当函数开始引用或被函数外部的代码所引用时，想要单靠 Rust 自身来确定参数或返回值的生命周期，就几乎是不可能的了。**函数所使用的生命周期可能在每次调用中都会发生变化。这也正是我们需要手动对生命周期进行标注的原因**。

当我们将具体的引用传入`longest`时，被用于替代`'a`的具体生命周期就是**作用域 x 与作用域 y 重叠的那一部分**。换句话说，**泛型生命周期`'a`会被具体化为`x`与`y`两者中生命周期较短的那一个**。因为我们将返回的引用也标记为了生命周期参数`'a`，所以返回的引用在具化后的生命周期范围内都是有效的。

### 深入理解生命周期

指定生命周期的方式往往取决于函数的具体功能。

```rs
fn longest<'a>(x: &'a str, y: &str) -> &'a str {
    x
}
```

在这个例子中，我们为参数 x 与返回类型指定了相同的生命周期参数'a，却有意忽略了参数 y，这是因为 y 的生命周期与 x 和返回值的生命周期没有任何相互关系。

_当函数返回一个引用时_，返回类型的生命周期参数**必须**要与其中一个参数的生命周期参数相匹配。当返回的引用没有指向任何参数时，那么它只可能是指向了一个创建于函数内部的值，由于这个值会因为函数的结束而离开作用域，所以返回的内容也就变成了**悬垂引用**。

```rs
fn longest<'a>(x: &str, y: &str) -> &'a str {
    let result = String::from("really long string");
    result.as_str()
}
```

即便我们在上面的代码中为返回类型指定了生命周期参数'a，这个实现也依然无法通过编译，因为返回值的生命周期没有与任何参数的生命周期产生关联。

这里的问题在于 result 在 longest 函数结束时就离开了作用域，并被清理。但我们依然在尝试从函数中返回一个指向 result 的引用。无论我们怎么改变生命周期参数，都无法阻止悬垂引用的产生，而 Rust**并不允许创建悬垂引用**。

最好的解决办法就是**返回一个持有自身所有权的数据类型**而不是引用，这样就可以将清理值的责任转移给函数调用者了。

### 结构体定义中的生命周期标注

可以在结构体中存储引用，不过需要为结构体定义中的每一个引用都添加生命周期标注

```rs
❶struct ImportantExcerpt<'a> {
 ❷ part: &'a str,
}

fn main() {
 ❸ let novel = String::from("Call me Ishmael. Some years ago...");
 ❹ let first_sentence = novel.split('.')
        .next()
        .expect("Could not find a '.'");
 ❺ let i = ImportantExcerpt { part: first_sentence };
}
```

### 生命周期省略

到目前为止，你应该已经知道，任何引用都有一个生命周期，并且需要为使用引用的函数或结构体指定生命周期参数。

编写了相当多的 Rust 代码后，Rust 团队发现，在某些特定情况下 Rust 程序员总是在一遍又一遍地编写同样的生命周期标注。这样的场景是可预测的，而且有一些明确的模式。于是，Rust 团队决定将这些模式直接写入编译器代码中，使借用检查器在这些情况下可以自动对生命周期进行推导而无须显式标注。

函数参数或方法参数中的生命周期被称为**输入生命周期**(input lifetime)，而返回值的生命周期则被称为**输出生命周期**(output lifetime)。

在没有显式标注的情况下，编译器目前使用了 3 种规则来计算引用的生命周期。第一条规则作用于输入生命周期，第二条和第三条规则作用于输出生命周期。

#### 第一条规则

**每一个引用参数都会拥有自己的生命周期参数**。换句话说，单参数函数拥有一个生命周期参数：`fn foo<'a>(x: &'ai32)`；双参数函数拥有两个不同的生命周期参数：`fn foo<'a, 'b>(x:&'a i32, y: &'b i32)`；以此类推。

#### 第二条规则

当只存在一个输入生命周期参数时，这个生命周期会被赋予给所有输出生命周期参数，例如`fn foo<'a>(x: &'a i32)-> &'a i32`。

#### 第三条规则

> 适用于方法签名

当拥有多个输入生命周期参数，而其中一个是`&self`或`&mut self`时，`self`的生命周期会被赋予给所有的输出生命周期参数。这条规则使方法更加易于阅读和编写，因为它省略了一些不必要的符号。

### 方法定义中的生命周期标注

```rs
// 应用第三条规则
impl<'a> ImportantExcerpt<'a> {
    fn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("Attention please: {}", announcement);
        self.part
    }
}
```

### 静态生命周期

Rust 中还存在一种特殊的生命周期`'static`，它表示整个程序的执行期。所有的字符串字面量都拥有`'static`生命周期，我们可以像下面一样显式地把它们标注出来：

```rs
let s: &'static str = "I have a static lifetime.";
```

字符串的文本被直接存储在二进制程序中，并总是可用的。因此，所有字符串字面量的生命周期都是`'static`。

**大部分情况下，错误的原因都在于尝试创建一个悬垂引用或可用生命周期不匹配**。

## 同时使用泛型参数、trait 约束与生命周期

```rs
use std::fmt::Display;

fn longest_with_an_announcement<'a, T>(x: &'a str, y: &'a str, ann: T) -> &'a str
    where T: Display
{
    println!("Announcement! {}", ann);
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

## 总结
我们在这一章学习了不少内容！现在，你应该对泛型参数、`trait`与`trait约束`，以及泛型生命周期参数等概念比较熟悉了，也应该可以在没有重复代码的前提下编写出适用于多种场景的代码。泛型参数可以使你将代码应用于不同的类型，而`trait`与`trait约束`则可以用来在代码中指定泛型的行为。除此之外，你还学到了如何使用生命周期来确保这些灵活的代码不会产生任何悬垂引用。所有的这些分析都将发生在编译过程中，而不会对运行时性能造成任何影响！

无论你是否相信，我们在本章讨论的内容都还有更多值得深入的细节：第17章将会讨论trait对象，这是另外一种使用trait的方式；第19章将会讨论某些涉及生命周期标注的高级类型系统功能。不过接下来，你会先学习如何在Rust中编写测试，它们可以确保你的代码能够按照预期的方式运行。